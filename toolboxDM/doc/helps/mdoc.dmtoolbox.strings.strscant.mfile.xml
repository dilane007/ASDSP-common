<?xml version='1.0'?>
<?xml-stylesheet type='text/xsl' href='../mfile_doc.xsl'?>
<MFileInfo mname='strscant' filename='strscant.m'>
  <Context is_root='true'>
    <Self path='mdoc.dmtoolbox.strings.strscant.mfile.xml'/>
    <Prev path='mdoc.dmtoolbox.strings.strscan.mfile.xml'/>
    <Next path='mdoc.dmtoolbox.strings.strsplit.mfile.xml'/>
    <Root path='mdoc.dmtoolbox.mdir.xml'/>
    <Parent path='mdoc.dmtoolbox.strings.mdir.xml'/>
  </Context>
  <MDoc mtype='function'>
    <MFuncDecl funcname='strscant'>
      <Inputs>
        <Var name='str'/>
        <Var name='pattern'/>
        <Var name='f'/>
        <Var name='inputform'/>
      </Inputs>
      <Outputs>
        <Var name='C'/>
      </Outputs>
    </MFuncDecl>
    <MHeadLine leadword='STRSCANT'>Scans the tokens of sub strings matching the specified patterns</MHeadLine>
    <MSection name='syntax'>
      <MList listtype='unordered'>
        <MListItem>
          <MParagraph>C = strscant(str, pattern, f)</MParagraph>
        </MListItem>
        <MListItem>
          <MParagraph>C = strscant(str, pattern, f, inputform)</MParagraph>
        </MListItem>
      </MList>
    </MSection>
    <MSection name='arguments'>
      <MTermList listtype='unordered'>
        <MTermEntry term='strs'>
          <MParagraph>the source string to be scanned</MParagraph>
        </MTermEntry>
        <MTermEntry term='pattern'>
          <MParagraph>the regular expression pattern (with tokens)</MParagraph>
        </MTermEntry>
        <MTermEntry term='f'>
          <MParagraph>the method to produce results from extracted tokens when f is empty, it can be omitted.</MParagraph>
        </MTermEntry>
        <MTermEntry term='inputform'>
          <MParagraph>the form of arguments input to f</MParagraph>
          <MTermList listtype='unordered'>
            <MTermEntry term='&apos;free&apos;'>
              <MParagraph>The default form</MParagraph>
              <MFormulaLine>r = f(token1, token2, ...)</MFormulaLine>
            </MTermEntry>
            <MTermEntry term='&apos;cell&apos;'>
              <MParagraph>the tokens are grouped into a cell</MParagraph>
              <MFormulaLine>r = f({token1, token2, ...})</MFormulaLine>
            </MTermEntry>
            <MTermEntry term='&apos;struct&apos;'>
              <MParagraph>the struct with named tokens</MParagraph>
              <MFormulaLine>r = f(s)</MFormulaLine>
            </MTermEntry>
          </MTermList>
        </MTermEntry>
        <MTermEntry term='C'>
          <MParagraph>the cell array of generated results</MParagraph>
        </MTermEntry>
      </MTermList>
    </MSection>
    <MSection name='description'>
      <MList listtype='unordered'>
        <MListItem>
          <MParagraph>C = strscant(str, pattern, f) scans the string using a regular expression pattern with tokens to capture. The extracted tokens for each matched sub string will be used by the the method specified in f to produce the corresponding results.</MParagraph>
          <MParagraph>f can be a function name, or a function handle. In these cases, the result for each match will be generated by invoking the function with free form.</MParagraph>
          <MParagraph>f can also be empty, then each element of C is a cell array of extracted tokens.</MParagraph>
          <MParagraph>If there are matched sub strings, the corresponding generated results will be grouped in a 1 x n cell array C and returned, where n is the number of matches. If str is empty or no matched sub strings are found, then an empty cell array will be returned.</MParagraph>
        </MListItem>
        <MListItem>
          <MParagraph>C = strscant(str, pattern, f, inputform) scans the string and generate the results with specified form.</MParagraph>
        </MListItem>
      </MList>
    </MSection>
    <MSection name='examples'>
      <MList listtype='unordered'>
        <MListItem>
          <MParagraph>Finds all the braced pairs of numbers in a string and group them into cell arrays.</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;(1,2), (3, 4)&apos;, &apos;\(\s*(\d+)\s*,\s*(\d+)\s*\)&apos;);</Line>
            <Line>     =&gt; {{&apos;1&apos;  &apos;2&apos;}, {&apos;3&apos;  &apos;4&apos;}}</Line>
          </MCodeBlock>
          <MParagraph>If you need to further convert the tokens into addition formulas:</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;(1,2), (3, 4)&apos;, &apos;\(\s*(\d+)\s*,\s*(\d+)\s*\)&apos;, ...</Line>
            <Line>              @(x, y) [x &apos; + &apos; y]);</Line>
            <Line>     =&gt; {&apos;1 + 2&apos;, &apos;3 + 4&apos;}</Line>
          </MCodeBlock>
          <MParagraph>Or, if you need to compute the sum of each pair of values:</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;(1,2), (3, 4)&apos;, &apos;\(\s*(\d+)\s*,\s*(\d+)\s*\)&apos;, ...</Line>
            <Line>              @(x, y) eval([x &apos;+&apos; y]));</Line>
            <Line>     =&gt; {[3], [7]}</Line>
          </MCodeBlock>
        </MListItem>
        <MListItem>
          <MParagraph>The following example shows a more complicated case: to produce addition formulas in string from the braced pairs of values.</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;(1,2), (3,4)&apos;, &apos;\(\s*(\d+)\s*,\s*(\d+)\s*\)&apos;, ...</Line>
            <Line>              @(x, y) [x &apos; + &apos; y &apos; = &apos; num2str(eval([x &apos;+&apos; y]))] );</Line>
            <Line>     =&gt; {&apos;1 + 2 = 3&apos;,  &apos;3 + 4 = 7&apos;}</Line>
          </MCodeBlock>
        </MListItem>
        <MListItem>
          <MParagraph>Using cell form for the result making function.</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;(1,2,3) (a,b,c)&apos;, &apos;\((\w+),(\w+),(\w+)\)&apos;, ...</Line>
            <Line>              @(c) [c{1}, &apos;+&apos;, c{2}, &apos;+&apos;, c{3}], &apos;cell&apos;);</Line>
            <Line>     =&gt; {&apos;1+2+3&apos;, &apos;a+b+c&apos;}</Line>
          </MCodeBlock>
        </MListItem>
        <MListItem>
          <MParagraph>Using named tokens to convert the scope synax from parent.child to parent::child</MParagraph>
          <MCodeBlock>
            <Line>     strscant(&apos;space.name class.method&apos;, ...</Line>
            <Line>              &apos;(?&lt;parent&gt;\w+)\.(?&lt;child&gt;\w+)&apos;, ...</Line>
            <Line>              @(s) [s.parent, &apos;::&apos;, s.child], &apos;struct&apos;);</Line>
            <Line>     =&gt; {&apos;space::name&apos;, &apos;class::method&apos;}</Line>
          </MCodeBlock>
        </MListItem>
      </MList>
    </MSection>
    <MSection name='remarks'>
      <MList listtype='unordered'>
        <MListItem>
          <MParagraph>This function wraps the regexp function with a concise interfac to handle tokens.</MParagraph>
        </MListItem>
      </MList>
    </MSection>
    <MSection name='history'>
      <MList listtype='unordered'>
        <MListItem>
          <MParagraph>Created by Dahua Lin, on Jun 24, 2007</MParagraph>
        </MListItem>
      </MList>
    </MSection>
  </MDoc>
</MFileInfo>
