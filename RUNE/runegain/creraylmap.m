function [raylmap, raylmapvec] = creraylmap(rhombvec,lambda,nlayer)
% DESCRIPTION
% [raylmap, raylmapvec] = creraylmap(rhombvec,lambda,nlayer)
%  Creates a rayleigh fading map with complex samples.
%  The map is generated by filtering white noise through a bessel function.
%  This is made with a fourirer method that will make the map periodic.
%  This property is used by useraylmap.m to cover the simulated area with
%  a rayleighpattern much like a wall paper. mapvec is an integer fraction of 
%  rhombvec. rhombvec are two complex vectors that span the simulated area.
% INPUT
%  rhombvec --    The size of the area that is going to be covered by the map.
%                Two complex vectors spanning the simulated area.
%  lambda  --    The wavelength in meter.
%  nlayer  --    The number of maps to be created ( Layered in 3rd dimension.
% OUTPUT 
%  raylmap --    A small map with rayleigh samples that is used by 
%                the function useraylmap to create the actual
%                multipath fading. The map spans atleast two dimensions
%                and possbly also the 3rd to store nlayer independent maps
%  raylmapvec -- Two complex elements spanning the area of the map. The first element 
%                spans the first dimension and the second element the second
%                dimension.
% TRY
%  mesh(2*lin2db(abs(creraylmap([1 i]*1000))))
% SEE ALSO
%  useraylmap

% by Magnus Almgren 031116
setifnotexistorempty('rhombvec','1000*[1 exp(i*2*pi/3)]'); % System mapsize
setifnotexistorempty('lambda',3e8/2e9); % Wavelenth [m]
setifnotexistorempty('nlayer',1); % Number of independent map (3rd dimension of raylmap)  

setifnotexistorempty('seed',2); % seed for the generated map
setifnotexistorempty('angmean',pi/2); % angle towards cluster
setifnotexistorempty('angsig',inf); % angular standard deviation of sources
setifnotexistorempty('N',2.^4); %  Number of samples in phase spectrum
setifnotexistorempty('M',2.^4); % Oversampling for the ifft. Makes the map smooth

if nlayer==0 % don't generate the map in this case
 raylmap = 0;
 raylmapvec = 0;
 return
end

% nn -- The number of times to repeat the map along rhombvec
margin = 0.1; % relative margin to the border of the map
n = imag(rhombvec(2)/(rhombvec(1)/abs(rhombvec(1))))/2/lambda;
nn = floor(n/(1+margin)); % 

% vectors spanning the map
raylmapvec(:,1) = linspace(0,rhombvec(1)/nn,N*M+1).';
raylmapvec(:,2) = linspace(0,rhombvec(2)/nn,N*M+1).'; 

% raylmap -- 1st and 2nd dimension <=> space, 3rd dimnension <=> timedelay
[raylmap, sqfs] = creraylangmap(seed,angmean,angsig,N,M,raylmapvec(end,:),lambda,nlayer);

% extend the map for wraparound linear interpolation in all dimensions
raylmap = raylmap([1:end 1],[1:end 1],:);

% $Id: creraylmap.m,v 1.2 2004/03/11 15:01:31 olav Exp $
