function  wxym = wrapinto(xym, rhombvec, type)
% DESCRIPTION
%  wxym = wrapinto(xym, rhombvec, type)
%  Matrix xym with complex elements will be wrapped into 
%  a rhomb that is generated by the two complex elements of 
%  rhombvec if type is equal to the string 'rhomb'.
%  In the same way xym will be wrapped into a hexagon if 
%  type is equal to 'hex'.
% INPUT
%  xym --      Position that should be wraped into the area
%  rhombvec -- A vector describing the rhombic area
%  type --     'hex' or 'rhomb'
% OUTPUT
%  wxym --     New positions in the rhombic area
% TRY  
%  plot(wrapinto(10*irandn(10000,1),exp(i*pi*[0 1]/3),'hex'),'.')
%  axis equal
%  plot(wrapinto(10*irandn(10000,1),exp(i*pi*[0 1]/3),'rhomb'),'.')
%  axis equal

% by Magnus Almgren 991122

% the inverse base of rhombvec. rhombvec(1)*base=>[1 0] rhombvec(2)*base=>[0 1] 
base = inv([real(rhombvec.') imag(rhombvec.')]);
rwa = [real(xym(:)) imag(xym(:))];  % first column real part and second imaginary

% wrap it back into the rhomb 
twa = rwa*base;
wxyv = mod(twa,1)*rhombvec.';
%wxyv = (twa - round(twa))*rhombvec.';
if strcmp(type,'hex')
 % wrap to shortest distance from origo (possibly a hexagon)
 rwcomb = mplus((-1:0)*rhombvec(1),(-1:0)'*rhombvec(2));
 if ~isempty(wxyv)
  wxyv = min(mplus(wxyv,rwcomb(:).'),[],2);
 end  
end
wxym = reshape(wxyv,size(xym));

% $Id: wrapinto.m,v 1.2 2004/03/11 15:01:31 olav Exp $
