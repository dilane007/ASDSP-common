<HTML>
<HEAD>
<TITLE>Manpage - runeft</TITLE>
</HEAD>

<BODY BGCOLOR="WHITE">

<CENTER><TABLE CELLSPACING=5 BORDER=0><TR><TD BGCOLOR="#A0A0A0" COLSPAN=2><UL>
<FONT SIZE=6 FACE="sans-serif"><B>runeft<B></FONT>
</UL></TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2">Description</FONT></TD>
<TD WIDTH=500><P>[res,par,sta,sys]=runeft(par,sta,sys)</P>
The basic rune dynamic function for TDMA. A number of time instances are simulated over time in the following way: A number of &quot;frames&quot; are simulated. How many and the time between them are determined by the frametime and nframes parameters. In each frame several slots are simulated determined by the slottime and nslots parameters. In each frame new calls arrive and terminate and calls are handed over if necessary. The traffic is the same for all slots in a frame, but since the mobiles move slightly they are exposed to fast (rayleigh) fading (controlled by the usefastf parameter) and possibly changing interference conditions due to frequency hopping (parameter usefh). Mobiles move between all time instants</TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2">Input</FONT></TD>
<TD><TABLE BORDER=0 CELLSPACING=5 WIDTH=500><TR><TD VALIGN="TOP"><B>par</B></TD><TD>BASIC SIMULATION PARAMETERS</TD></TR>
<TR><TD VALIGN="TOP"><B>par.frametime</B></TD><TD>time interval in the simulation loop</TD></TR>
<TR><TD VALIGN="TOP"><B>par.nframes</B></TD><TD>number of iterations in the main loop</TD></TR>
<TR><TD VALIGN="TOP"><B>par.slottime</B></TD><TD>time per slot in seconds</TD></TR>
<TR><TD VALIGN="TOP"><B>par.nslots</B></TD><TD>number of slots per frame</TD></TR>
<TR><TD VALIGN="TOP"><B>par.seed</B></TD><TD>seed to all random sequencies in the simulation</TD></TR>
<TR><TD VALIGN="TOP"><B>par.cellradius</B></TD><TD>cell radius [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.km</B></TD><TD>km^2+lm^2+km*lm =&gt; the number of sites</TD></TR>
<TR><TD VALIGN="TOP"><B>par.lm</B></TD><TD>related to km above</TD></TR>
<TR><TD VALIGN="TOP"><B>par.sps</B></TD><TD>number of sectors per site</TD></TR>
<TR><TD VALIGN="TOP"><B>par.gainconst</B></TD><TD>gain at 1 meter distance [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.alpha</B></TD><TD>distance attenuation coefficient</TD></TR>
<TR><TD VALIGN="TOP"><B>par.noise</B></TD><TD>thermal noise floor [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.sigma</B></TD><TD>standard deviation for the lognormal fading [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.raa</B></TD><TD>lognormal correlation down link (typical 0.5)</TD></TR>
<TR><TD VALIGN="TOP"><B>par.corrdist</B></TD><TD>lognormal fading correlation distance [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.offtraf</B></TD><TD>average number of offered calls to a cell [Erlang/cell]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.mht</B></TD><TD>mean holding time [seconds]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.amean</B></TD><TD>average acceleration [m/s/s]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.vmean</B></TD><TD>average speed [m/s]</TD></TR>
<TR><TD VALIGN="TOP"><B>par.homargin</B></TD><TD>gain margin between two bases used at Hand Off</TD></TR>
<TR><TD VALIGN="TOP"><B>par.pinit</B></TD><TD>initial power assigned to one transmitter</TD></TR>
<TR><TD VALIGN="TOP"><B>par.rbermax</B></TD><TD>raw bit error level over which a frame is lost</TD></TR>
<TR><TD VALIGN="TOP"><B>par.usefastf</B></TD><TD>make use of fast fading</TD></TR>
<TR><TD VALIGN="TOP"><B>par.kn</B></TD><TD>kn^2+ln^2+kn*ln =&gt; the number of clusters</TD></TR>
<TR><TD VALIGN="TOP"><B>par.ln</B></TD><TD>related to kn above</TD></TR>
<TR><TD VALIGN="TOP"><B>par.kpc</B></TD><TD>number of allocated channels per cell</TD></TR>
<TR><TD VALIGN="TOP"><B>par.usefh</B></TD><TD>reselection of frequency every slot if 1</TD></TR>
<TR><TD VALIGN="TOP"><B>sta</B></TD><TD>STATE variable that is changed at every iteration</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.seed</B></TD><TD>the seed before next iteration</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.time</B></TD><TD>sample time</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.m</B></TD><TD>mobile identity number</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.mtop</B></TD><TD>max mobile number used sofar</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.xym</B></TD><TD>position in complex form [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.xyv</B></TD><TD>speed imag &lt;=&gt; north real &lt;=&gt; east [m/s]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.gmb</B></TD><TD>the gain matrix (slow part)</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.rgumb</B></TD><TD>rayleigh fading gain for the uplink</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.rgdmb</B></TD><TD>rayleigh fading gain for the downlink</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.m</B></TD><TD>mobile identity number</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.b</B></TD><TD>base station index</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.k</B></TD><TD>channel number</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.mtop</B></TD><TD>max mobile number used sofar</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.pul</B></TD><TD>transmitted power up link [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.cul</B></TD><TD>received carrier power up link [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.iul</B></TD><TD>interference power up link [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.sirul</B></TD><TD>signal to interference ratio up link [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.fepul</B></TD><TD>frame error probability for each user</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.pdl</B></TD><TD>transmitted power down link [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.cdl</B></TD><TD>carrier downlink [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.idl</B></TD><TD>interference down link [dBm]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.sirdl</B></TD><TD>signal to interference down link [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.fepdl</B></TD><TD>frame error probability for each user</TD></TR>
<TR><TD VALIGN="TOP"><B>sta.obk</B></TD><TD>the allocation of channels</TD></TR>
<TR><TD VALIGN="TOP"><B>sys</B></TD><TD>ALL INTERMEDIATE VALUES NEEDED TO SIMULATE</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.xyb</B></TD><TD>base positions [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.fib</B></TD><TD>cell center vector [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.rhombvec</B></TD><TD>system vectors [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.raylmap</B></TD><TD>rayleigh map [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.raylmapvec</B></TD><TD>rayleigh map vectors [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.lognmap</B></TD><TD>lognormal map [dB]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.lognmapvec</B></TD><TD>lognormal map vectors [m]</TD></TR>
<TR><TD VALIGN="TOP"><B>sys.iniobk</B></TD><TD>channel plan</TD></TR>
</TABLE>
</TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2">Output</FONT></TD>
<TD><TABLE BORDER=0 CELLSPACING=5 WIDTH=500><TR><TD VALIGN="TOP"><B>res</B></TD><TD>cellarray of sta collected for each iteration of the simulation</TD></TR>
<TR><TD VALIGN="TOP"><B>par</B></TD><TD>same as input otherwise created within the function</TD></TR>
<TR><TD VALIGN="TOP"><B>sta</B></TD><TD>same structure as input otherwise created within the function</TD></TR>
<TR><TD VALIGN="TOP"><B>sys</B></TD><TD>same as input otherwise created within the function</TD></TR>
</TABLE>
</TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2">Try</FONT></TD>
<TD><PRE>[res, par, sta, sys] = runeft</PRE></TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2">See Also</FONT></TD>
<TD><A HREF="setpart.html">setpart</A></TD></TR>
<TR><TD COLSPAN=2 HEIGHT=6><FONT SIZE="-7">&nbsp;</FONT></TD></TR>

<TR><TD VALIGN="TOP"><FONT SIZE="+2" COLSPAN=2>Source Code</TD></TR>
<TR><TD COLSPAN=2><PRE>function [res, par, sta, sys] = runeft(par, sta, sys) 

<FONT COLOR="DARKGREEN">% by Magnus Almgren 040211	</FONT>

<FONT COLOR="DARKGREEN">% set simulation parameter par if not present as an input</FONT>
if ~exist('par','var'), par = <A HREF="setpart.html">setpart</A>; end <FONT COLOR="DARKGREEN">% default parameter setting</FONT>
oseed = <A HREF="../runetools/setseed.html">setseed</A>(par.seed); <FONT COLOR="DARKGREEN">% Set the seed in random generators</FONT>

<FONT COLOR="DARKGREEN">% Create the sys variable if not present as an input.</FONT>
if ~exist('sys','var') | isempty(sys)
 <FONT COLOR="DARKGREEN">% generate base station position and directions </FONT>
 clear sys
 [sys.xyb, sys.fib, sys.rhombvec] = <A HREF="../runegain/crecells.html">crecells</A>(par.cellradius,par.sps,par.km,par.lm,...
 par.kn,par.ln);

 <FONT COLOR="DARKGREEN">% Create a lognormal map. The lognormal map is dependent on the seed.</FONT>
 oseed1 = <A HREF="../runetools/setseed.html">setseed</A>(par.seed);  <FONT COLOR="DARKGREEN">% Set seed of pseudo random generator for the map.</FONT>
 [sys.lognmap, sys.lognmapvec] = <A HREF="../runegain/crelognmap.html">crelognmap</A>(sys.xyb, sys.rhombvec, par.corrdist); 
 
 <FONT COLOR="DARKGREEN">% Create a rayleigh fading map if par.usefastf = 1.</FONT>
 [sys.raylmap, sys.raylmapvec] = <A HREF="../runegain/creraylmap.html">creraylmap</A>(sys.rhombvec,[],par.usefastf);
 sys.xyboffsrayl = <A HREF="../runetools/irandn.html">irandn</A>(size(sys.xyb))*sys.rhombvec(1); <FONT COLOR="DARKGREEN">% offset for fast fading</FONT>

 <A HREF="../runetools/setseed.html">setseed</A>(oseed1);  <FONT COLOR="DARKGREEN">% Restore seed to original value.</FONT>

 <FONT COLOR="DARKGREEN">% Create a channel plan for the system.</FONT>
 <FONT COLOR="DARKGREEN">% Number of channels that is used in each cluster.</FONT>
 nclusters = par.kn^2+par.ln^2+par.kn*par.ln;
 nk = length(sys.xyb)/nclusters*par.kpc;   	
 sys.iniobk  = <A HREF="crechanplan.html">crechanplan</A>(length(sys.xyb),nk,nclusters);  <FONT COLOR="DARKGREEN">% Allocate channels to cells</FONT>
end

<FONT COLOR="DARKGREEN">% Init of state variable</FONT>
<FONT COLOR="DARKGREEN">% The variables below are altered in the for loop and saved after each iteration</FONT>
if ~exist('sta','var') | isempty(sta)
 clear sta
 e = zeros(0,1);
 e1 = zeros(0,size(sys.xyb,2));
 sta.seed  = par.seed; sta.time = 0; sta.m = e; sta.mtop  = 0; sta.xym = e; sta.xyv = e; sta.gmb = e1;

 sta.m     = e;  sta.b     = e;  sta.k     = e; sta.mtop  = 0; 
 sta.pul   = e;  sta.cul   = e;  sta.iul   = e;  sta.sirul = e;  sta.fepul = e;
 sta.pdl   = e;  sta.cdl   = e;  sta.idl   = e;  sta.sirdl = e;  sta.fepdl = e;
 sta.obk   = sys.iniobk;
end
<A HREF="../runetools/setseed.html">setseed</A>(sta.seed); <FONT COLOR="DARKGREEN">% Set seed in random generators.</FONT>

<FONT COLOR="DARKGREEN">% The simulation loop. One iteration corresponds to one frame</FONT>
for iframe = 1:par.nframes
 dt = par.frametime-par.nslots*par.slottime;
 sta.time = sta.time+dt; <FONT COLOR="DARKGREEN">% Timestamp</FONT>
 
 <FONT COLOR="DARKGREEN">% Terminate some calls due to hang up.</FONT>
 terones = isfinite(sta.k) & (rand(size(sta.xym)) < 1-exp(-<A HREF="../runetools/mdiv.html">mdiv</A>(par.frametime,par.mht))); <FONT COLOR="DARKGREEN">% Toss one biased Coin per active user</FONT>
 drones = sta.fepul | sta.fepdl; <FONT COLOR="DARKGREEN">% quality dropping</FONT>

 <FONT COLOR="DARKGREEN">% Terminate by setting b and k to NaN and release channel by setting obk to 1</FONT>
 [sta.b,sta.k,sta.obk] = <A HREF="terminate.html">terminate</A>(sta.b,sta.k,sta.obk,terones | drones);

 <FONT COLOR="DARKGREEN">% Make a realisation of new users. </FONT>
 <FONT COLOR="DARKGREEN">% At first iteration full traffic is generated</FONT>
 incr = 1 - (sta.time~=dt).*exp(-<A HREF="../runetools/mdiv.html">mdiv</A>(par.frametime,par.mht));
 <FONT COLOR="DARKGREEN">% Average number of users to create</FONT>
 nmobavg = par.offtraf .* size(sys.xyb,2).* incr; 
 veclength = round(max(100, 10*nmobavg)); <FONT COLOR="DARKGREEN">% At least a pool of 100 idle users to draw from </FONT>
 nmob = sum(rand(veclength,1) < nmobavg/veclength); <FONT COLOR="DARKGREEN">% Tosse all the Coins</FONT>

 <FONT COLOR="DARKGREEN">% Refresh vector structure by removing released calls and adding new ones.</FONT>
 nt1 = <A HREF="../runetools/nans.html">nans</A>(nmob,1);  <FONT COLOR="DARKGREEN">% NaN vector used as concatenation of xym xyb etc.</FONT>
 ntb = <A HREF="../runetools/nans.html">nans</A>(nmob,size(sys.xyb,2));  <FONT COLOR="DARKGREEN">% Nans vector used to concatenate gmb pumb etc.</FONT>
 sta.mtop = sta.mtop+nmob; <FONT COLOR="DARKGREEN">% highest mobile id so far </FONT>
  
 keep = isfinite(sta.k);  <FONT COLOR="DARKGREEN">% Clean out all users with k == nan</FONT>
 <FONT COLOR="DARKGREEN">% Several of these updates are not necessary but is done in order to ease debugging</FONT>
 sta.xym   =[sta.xym(keep);       nt1]; 
 sta.xyv   =[sta.xyv(keep);       nt1]; 
 sta.m     =[sta.m(keep); sta.mtop+(1:nmob)']; 
 sta.gmb   =[sta.gmb(keep,:);     ntb]; 

 sta.b     =[sta.b(keep);         nt1]; 
 sta.k     =[sta.k(keep);         nt1]; 
 
 sta.pul   =[sta.pul(keep);       nt1]; 
 sta.cul   =[sta.cul(keep);       nt1]; 
 sta.iul   =[sta.iul(keep);       nt1]; 
 sta.sirul =[sta.sirul(keep);     nt1];
 sta.fepul =[sta.fepul(keep);     nt1];
 
 sta.pdl   =[sta.pdl(keep);       nt1]; 
 sta.cdl   =[sta.cdl(keep);       nt1]; 
 sta.idl   =[sta.idl(keep);       nt1]; 
 sta.sirdl =[sta.sirdl(keep);     nt1];
 sta.fepdl =[sta.fepdl(keep);     nt1];
 
 <FONT COLOR="DARKGREEN">% Move old users and initiate a position to newcomers.</FONT>
 [sta.xym,sta.xyv] = <A HREF="../runegain/mobmove.html">mobmove</A>(sta.xym,sta.xyv,par.amean,par.vmean,dt,sys.rhombvec);

 <FONT COLOR="DARKGREEN">% Calculate the gain matrix. Size is terminals  by bases</FONT>
 sta.gmb = <A HREF="../runegain/pathgain.html">pathgain</A>(sta.xym, sys.xyb, sys.fib, par.sps, sys.rhombvec, ...
  par.gainconst, par.alpha, par.sigma, par.raa, ...
  sys.lognmap, sys.lognmapvec);

 <FONT COLOR="DARKGREEN">% Perform handoff & Allocate new mobiles to a channel if possible.</FONT>
 [sta.b,sta.k,sta.obk] = <A HREF="handofft.html">handofft</A>(sta.b,sta.k,sta.gmb,sta.obk,par.homargin);
 
 <FONT COLOR="DARKGREEN">% Try to assign channels to new calls.</FONT>
 [sta.b,sta.k,sta.obk] = <A HREF="assign.html">assign</A>(sta.b,sta.k,sta.gmb,sta.obk,par.homargin);
 
 sta.pul(isnan(sta.pul)) = par.pinit; <FONT COLOR="DARKGREEN">% Set power to new users </FONT>
 sta.pdl(isnan(sta.pdl)) = par.pinit;
 
 <FONT COLOR="DARKGREEN">% Reset power of terminated users.</FONT>
 sta.pul(isnan(sta.k)) = nan; 
 sta.pdl(isnan(sta.k)) = nan;
 
 <FONT COLOR="DARKGREEN">% init of variables for the inner loop </FONT>
 <FONT COLOR="DARKGREEN">% The inner Loop Power collected in a matrix of size users by bases by timeslots</FONT>
 sirumbt = <A HREF="../runetools/nans.html">nans</A>([size(sta.gmb,1) par.nslots]); sirdmbt = sirumbt; <FONT COLOR="DARKGREEN">% reserve memory</FONT>
 for islot = 1:par.nslots
  dt = par.slottime;
  sta.time = sta.time + dt;
  
  <FONT COLOR="DARKGREEN">% Move users one slot forward</FONT>
  [sta.xym,sta.xyv] = <A HREF="../runegain/mobmove.html">mobmove</A>(sta.xym,sta.xyv,par.amean,par.vmean,dt,sys.rhombvec);
  
  if par.usefh <FONT COLOR="DARKGREEN">% if frequency hopping mode is selected</FONT>
   <FONT COLOR="DARKGREEN">% Perform frequency hopping by reselection all channels</FONT>
   btemp = sta.b;
   btemp(isnan(sta.k)) = NaN;
   [sta.k, sta.obk] = <A HREF="radchanalloc.html">radchanalloc</A>(btemp, sys.iniobk);
  end
  
  <FONT COLOR="DARKGREEN">% compute flat fading gain as a matrix of the same size as sta.gmb</FONT>
  sta.rgumb = <A HREF="../runetools/lin2db.html">lin2db</A>(abs(<A HREF="../runegain/useraylmap.html">useraylmap</A>(<A HREF="../runetools/mplus.html">mplus</A>(+sys.xyboffsrayl,-sta.xym), sys.raylmap, sys.raylmapvec)).^2);
  sta.rgdmb = <A HREF="../runetools/lin2db.html">lin2db</A>(abs(<A HREF="../runegain/useraylmap.html">useraylmap</A>(<A HREF="../runetools/mplus.html">mplus</A>(-sys.xyboffsrayl,-sta.xym), sys.raylmap, sys.raylmapvec)).^2);
  
  <FONT COLOR="DARKGREEN">% Perform the transmission from the sending to the receiving side, all in dB or dBm.</FONT>
  [sta.cul, sta.iul, sta.sirul] = <A HREF="transmitul.html">transmitul</A>(sta.b, sta.k, sta.pul, sta.gmb+sta.rgumb, par.noise); <FONT COLOR="DARKGREEN">% up link</FONT>
  [sta.cdl, sta.idl, sta.sirdl] = <A HREF="transmitdl.html">transmitdl</A>(sta.b, sta.k, sta.pdl, sta.gmb+sta.rgdmb, par.noise); <FONT COLOR="DARKGREEN">% down link</FONT>

  <FONT COLOR="DARKGREEN">% Collect C/I for mobiles,bases and slots</FONT>
  sirumbt(:,islot) = sta.sirul;
  sirdmbt(:,islot) = sta.sirdl;

  sta.seed = <A HREF="../runetools/setseed.html">setseed</A>; <FONT COLOR="DARKGREEN">% Save seed to faciliate simulation from this state</FONT>
  <FONT COLOR="DARKGREEN">% Save some results</FONT>
  res(islot,iframe)= sta;
 end
 
 <FONT COLOR="DARKGREEN">% Frame Error Probability up and down link</FONT>
 sta.fepul = mean(<A HREF="../runegain/ci2rber.html">ci2rber</A>(<A HREF="../runetools/linsum.html">linsum</A>(sirumbt,2)),3) > par.rbermax;
 sta.fepdl = mean(<A HREF="../runegain/ci2rber.html">ci2rber</A>(<A HREF="../runetools/linsum.html">linsum</A>(sirdmbt,2)),3) > par.rbermax;
 sta.seed = <A HREF="../runetools/setseed.html">setseed</A>; <FONT COLOR="DARKGREEN">% Save seed to faciliate simulation from this state</FONT>
end
    
<A HREF="../runetools/setseed.html">setseed</A>(oseed); <FONT COLOR="DARKGREEN">% Restore seed to original value</FONT>
<FONT COLOR="DARKGREEN">% $Id: runeft.m,v 1.2 2004/03/11 22:58:32 olav Exp $</FONT>
</PRE></TD></TR>
</TABLE></CENTER>
</BODY>
</HTML>